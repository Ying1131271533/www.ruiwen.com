<?php

// RabbitMQ 主题模式
namespace app\common\command;

use app\common\lib\classes\rabbitmq\RabbitMqConnection;
use think\console\Command;
use think\console\Input;
use think\console\Output;
use think\facade\Log;

class Topic extends Command
{
    protected function configure()
    {
        parent::configure(); // TODO: Change the autogenerated stub
        $this->setName('topic');
    }

    protected function execute(Input $input, Output $output)
    {
        // 获取连接对象
        $connection = RabbitMqConnection::getConnection();
        // 获取通道
        $channel = $connection->channel();

        // 声明交换机
        $channel->exchange_declare('topics', 'topic', false, true, false);

        // 创建一个临时队列并获取队列名称
        list($queueName) = $channel->queue_declare('', false, true, true, false);

        // 绑定队列和交换机，动态通配符形式 route_key
        // .*可以匹配1个
        // $channel->queue_bind($queueName, 'topics', '*.user.*');
        // .#可以匹配0到多个，所以user也可以消费
        // 当队列绑定关系是下列这种情况时需要引起注意
        // 当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像fanout了
        // 如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是像direct 了
        $channel->queue_bind($queueName, 'topics', '*.user.#');
        // $channel->queue_bind($queueName, 'topics', '#.user.#');
        echo "[*] Waiting for logs. To exit press CTRL+C \n";

        $callback = function ($msg) {
            echo "[x] 消费者1\n";
            // echo "[x] 消费者2\n";
            echo '[x] 路由键: ', $msg->delivery_info['routing_key'], "\n";
            echo '[x] 消息: ', $msg->body, "\n";
        };
        // 消费消息
        $channel->basic_consume($queueName, '', false, true, false, false, $callback);

        // 监听通道消息
        while (count($channel->callbacks)) {
            $channel->wait();
        }
        
        // 关闭连接
        RabbitMqConnection::closeConnectionAndChannel($connection, $channel);
    }

}
