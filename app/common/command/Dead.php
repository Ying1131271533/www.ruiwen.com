<?php

// 死信队列练习 - 死信消费者
namespace app\common\command;

use app\common\lib\classes\rabbitmq\RabbitMqConnection;
use PhpAmqpLib\Wire\AMQPTable;
use think\console\Command;
use think\console\Input;
use think\console\Output;
use think\facade\Log;

class Dead extends Command
{
    protected function configure()
    {
        parent::configure(); // TODO: Change the autogenerated stub
        $this->setName('dead');
    }

    protected function execute(Input $input, Output $output)
    {
        // 获取连接
        $connection = RabbitMqConnection::getConnection(['vhost' => 'order']);
        // 获取通道
        $channel = $connection->channel();

        // 死信队列名称
        $dead_queue = 'dead_queue';
        // 死信交换机名称
        $dead_exchange = 'dead_exchange';
        // 死信routing_key
        $dead_routing_key = 'dead_routing_key';

        // 声明交换机
        $channel->exchange_declare($dead_exchange, 'direct', false, false, false);
        // 如果要先启动消费者，必须要声明队列
        $channel->queue_declare($dead_queue, false, true, false, false);
        // 将队列名与交换机名进行绑定，并指定routing_key
        $channel->queue_bind($dead_queue, $dead_exchange, $dead_routing_key);

        echo "[*] Waiting for logs. To exit press CTRL+C \n";
        $callback = function ($msg) {
            echo "死信消费者: $msg->body \n";
            // 确认消息已被消费，从生产队列中移除
            $msg->ack();
            // 第三种死信情况 消息拒答
            // 参数1：是否把消息放回队列 默认false
            // 参数2：是否批量处理 默认false
            // $msg->nack(true);
        };

        // 设置消费成功后才能继续进行下一个消费
        $channel->basic_qos(null, 1, null);

        // 开启消费no_ack=false,设置为手动应答
        $channel->basic_consume($dead_queue, '', false, false, false, false, $callback);

        // 不断循环消费
        while ($channel->is_open()) {
            $channel->wait();
        }

        // 关闭连接
        RabbitMqConnection::closeConnectionAndChannel($channel, $connection);
    }

}
