<?php

// Task异步任务，这个Task是给HTTP、UDP、WebScoket等等这些服务器来使用的
// 这里就是给WebScoket做异步的
namespace app\common\command\swoole;

use think\console\Command;
use think\console\Input;
use think\console\Output;

class WebSocketTask extends Command
{
    protected function configure()
    {
        parent::configure(); // TODO: Change the autogenerated stub
        $this->setName('web_socket_task');
    }

    protected function execute(Input $input, Output $output)
    {
        // 创建WebSocket Server对象，监听0.0.0.0:9502端口
        // 参数4：WebSocket是基于tcp做成的协议，打开ssl
        // $ws = new \Swoole\WebSocket\Server('0.0.0.0', 9502, SWOOLE_PROCESS, SWOOLE_SOCK_TCP | SWOOLE_SSL);
        // 不使用ssl
        $ws = new \Swoole\WebSocket\Server('0.0.0.0', 9502);

        // 用于设置运行时的各项参数
        $ws->set([
            'task_worker_num'       => 4, // 设置异步任务的工作进程数量
            // 静态文件
            'enable_static_handler' => true,
            // 根目录，放置html等其它的静态文件，直接访问
            'document_root'         => '/var/www/www.ruiwen.com/app/common/command/swoole/static',
        ]);

        // 监听连接打开事件
        $ws->on('Open', [$this, 'onOpen']);

        // 监听消息事件
        $ws->on('Message', [$this, 'onMessage']);

        // 处理异步任务(此回调函数在task进程中执行)
        $ws->on('Task', [$this, 'onTask']);

        // 处理异步任务的结果(此回调函数在worker进程中执行)
        $ws->on('Finish', [$this, 'onFinish']);

        // 监听连接关闭事件
        $ws->on('Close', [$this, 'onClose']);

        //启动服务器
        $ws->start();
    }

    // 监听WebSocket连接打开事件
    public function onOpen($ws, $request)
    {
        var_dump($request->fd, $request->get, $request->server);
        $ws->push($request->fd, "客户端：{$request->fd}，打开连接，进入聊天室\n");
    }

    // 此回调函数在worker进程中执行
    public function onReceive($ws, $fd, $reactor_id, $data)
    {
        //投递异步任务
        $task_id = $ws->task($data);
        echo "Dispatch AsyncTask: id={$task_id}\n";
    }

    // 监听WebSocket连接打开事件
    // 参数1：所有连接数据
    // 参数2：正在发送消息的用户的连接数据
    // ！！！我在这里测试的时候出现了一个问题，连接fd有1、2、4
    // 一共产生了fd为1、2、3、4、5的连接，观察命令行发现3和5关闭了连接，但是2还保持着连接
    // 然后$ws里面的连接fd没有2，导致$ws-push发送不了
    // 解决方法：使用$ws->isEstablished($fd)判断是否为有效连接，或者使用try
    public function onMessage($ws, $frame)
    {
        echo "消息: {$frame->data}\n";
        // WebSocket会存储所有用户连接进来的fd
        foreach ($ws->connections as $fd) {
            dump($fd);
            // 需要先判断是否是正确的websocket连接，否则有可能会push失败
            if ($ws->isEstablished($fd)) {
                // 场景设定为1:1聊天
                // 和正在连接的fd进行对比，例如我fd-01和对方fd-02正在聊天
                // 判断是我，还是对方发送的消息
                if ($fd == $frame->fd) {
                    // 投递一个异步任务到 task_worker 池中。此函数是非阻塞的，执行完毕会立即返回。
                    // Worker 进程可以继续处理新的请求。
                    // 使用 Task 功能，必须先设置 task_worker_num ，并且必须设置 Server 的 onTask 和 onFinish 事件回调函数。
                    $ws->task([
                        'fd'      => $fd,
                        'messags' => "我发送的消息: {$frame->data}",
                    ]);
                    // 服务端用fd来向客户端用户：我，发送消息，返回消息是告知是我发送的消息
                    $ws->push($fd, "我发送的消息: {$frame->data}");
                } else {
                    // 服务端用fd来向客户端用户：对方，发送消息，返回消息是告知是对方发送的消息
                    $ws->push($fd, "对方发送的消息: {$frame->data}");
                    /* try {
                        $ws->push($fd, "对方发送的消息: {$frame->data}");
                    } catch (\Throwable $th) {
                        echo '无效的连接，fd：' . $fd;
                    } */
                }
            };
        }
    }

    // 处理异步任务(此回调函数在task进程中执行)
    // $task_id 有可能会出现相同
    // 【$task_id 和 $src_worker_id 组合起来才是全局唯一的，不同的 worker 进程投递的任务 ID 可能会有相同】
    public function onTask($ws, $task_id, $reactor_id, $data)
    {
        // 为了方便观察异步，睡眠十秒
        sleep(10);
        // 这里是return到onFinish()
        return $data;
        // echo "New AsyncTask[id={$task_id}]" . PHP_EOL;
        // 返回任务执行的结果
        // $ws->finish("{$data} -> OK");
    }

    // 处理异步任务的结果(此回调函数在worker进程中执行)
    public function onFinish($ws, $task_id, $data)
    {
        var_dump('task_id：' . $task_id);
        var_dump($data);
        // echo "AsyncTask[{$task_id}] Finish: {$data}" . PHP_EOL;
    }

    // 监听WebSocket连接关闭事件
    public function onClose($ws, $fd)
    {
        echo "客户端-{$fd}：关闭连接\n";
    }

}
