<?php

// RabbitMQ 广播 练习
namespace app\common\command;

use app\common\lib\classes\rabbitmq\RabbitMqConnection;
use think\console\Command;
use think\console\Input;
use think\console\Output;
use think\Log;

class Consumer extends Command
{
    protected function configure()
    {
        parent::configure(); // TODO: Change the autogenerated stub
        $this->setName('consumer');
    }

    protected function execute(Input $input, Output $output)
    {
        // 获取连接对象
        $connection = RabbitMqConnection::getConnection();
        // 获取通道
        $channel = $connection->channel();

        // 通道绑定对象
        // 这里要注意的是，生产者和消费者的队列参数必需一致
        // 参数1：队列名称
        $channel->queue_declare('akali_queue', false, true, false, true);
        // $channel->queue_declare('hello', false, false, false, true);

        echo ' [*] Waiting for messages. To exit press Ctrl+C', "\n";

        // 回调函数
        $callback = function ($msg) {
            echo " [x] Received ", $msg->body, "\n";

            // 判断获取到quit后退出
            if (trim($msg->body) == 'quit') {
                $msg->getChannel()->basic_cancel($msg->getConsumerTag());
            }
        };

        // 消费信息
        // 参数1:消费那个队列的消息队列名称
        // 参数2:虚拟主机
        // 参数4:开始消息的自动确认机制
        // 参数7:消费时的回调接口
        $channel->basic_consume('akali_queue', '', false, true, false, false, $callback);
        // $channel->basic_consume('hello', '', false, true, false, false, $callback);

        // 监听通道消息
        while (count($channel->callbacks)) {
            $channel->wait();
        }

        // 关闭连接
        RabbitMqConnection::closeConnectionAndChannel($connection, $channel);
    }

}
