<?php

// RabbitMQ 广播 练习
namespace app\common\command;

use app\common\lib\classes\rabbitmq\RabbitMqConnection;
use think\console\Command;
use think\console\Input;
use think\console\Output;
use think\facade\Log;

class ConsumerConfirm extends Command
{
    protected function configure()
    {
        parent::configure(); // TODO: Change the autogenerated stub
        $this->setName('consumerConfirm');
    }

    protected function execute(Input $input, Output $output)
    {
        // 获取连接对象
        $connection = RabbitMqConnection::getConnection();
        // 获取通道
        $channel = $connection->channel();
        
        // 声明队列
        $channel->queue_declare('hello', false, true, false, false);
        // 这里只是看看耗时，不持久化
        // $channel->queue_declare('hello', false, false, false, false);

        echo ' [*] Waiting for messages. To exit press Ctrl+C', "\n";
        
        // 回调函数
        $callback = function ($msg) {
            echo "[x] 消费者-1：", $msg->body, "\n";
            // echo "[x] 消费者-2：", $msg->body, "\n";
            // sleep(1);
            // sleep(5);
            // 消息拒答
            // 参数1：是否把消息放回队列 默认false
            // 参数2：是否批量处理 默认false
            // $msg->nack();

            // 参数1：发布标签
            // 参数2：是否批量处理 默认false
            // 参数3：是否把消息放回队列 默认false
            // $msg->delivery_info['channel']->basic_nack($msg->delivery_info['delivery_tag']);
            
            // 消息确认
            // 参数1：是否批量处理 默认false
            // $msg->ack();
            // 参数1：发布标签
            // 参数2：是否批量处理 默认false
            $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);
        };

        // 开启消费
        $channel->basic_consume('hello', '', false, false, false, false, $callback);

        // 监听通道消息，这里没有的话，消费完消息就会自动退出
        while (count($channel->callbacks)) {
            $channel->wait();
        }

        // 关闭连接
        RabbitMqConnection::closeConnectionAndChannel($connection, $channel);
    }

}
