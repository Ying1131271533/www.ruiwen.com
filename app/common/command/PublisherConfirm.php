<?php

// RabbitMQ 广播 练习
namespace app\common\command;

use app\common\lib\classes\rabbitmq\RabbitMqConnection;
use PhpAmqpLib\Message\AMQPMessage;
use think\cache\driver\Redis;
use think\console\Command;
use think\console\Input;
use think\console\Output;
use think\facade\Log;

class PublisherConfirm extends Command
{
    protected function configure()
    {
        parent::configure(); // TODO: Change the autogenerated stub
        $this->setName('publisherConfirm');
    }

    protected function execute(Input $input, Output $output)
    {
        // 获取连接
        $connection = RabbitMqConnection::getConnection();

        // 获取连接中通道
        $channel = $connection->channel();

        // 已发布的消息数组，不知道要不要用redis保存，用了redis耗时超大
        // $outStandingConfirm = [];

        // 确认投放队列，并将队列持久化
        $channel->queue_declare('hello', false, true, false, false);
        // 这里只是看看耗时，不持久化
        // $channel->queue_declare('hello', false, false, false, false);

        // 异步回调消息确认 成功
        $channel->set_ack_handler(
            function (AMQPMessage $message) {
                echo "Message acked with content " . $message->body . PHP_EOL;
                echo "Tag " . $message->delivery_info['delivery_tag'] . PHP_EOL;
                // 删除已经确认的消息
                (new Redis(config('app.redis')))->hDel('hello', $message->delivery_info['delivery_tag']);
            }
        );
        // 异步回调消息确认 失败
        $channel->set_nack_handler(
            function (AMQPMessage $message) {
                echo "Message nacked with content " . $message->body . PHP_EOL;
            }
        );
        //消息到达交换机,但是没有进入合适的队列,消息回退
        $channel->set_return_listener(function (
            $reply_code,
            $reply_text,
            $exchange,
            $routing_key,
            AMQPMessage $msg
        ) use (
            $channel,
            $connection
        )
        {
            echo '消息退回,入队失败逻辑'.PHP_EOL;
            // 关闭连接
            RabbitMqConnection::closeConnectionAndChannel($channel, $connection);
            exit();
        });

        // 开启消息发布确认，选择为 confirm 模式（此模式不可以和事务模式 兼容）
        $channel->confirm_select();

        // 获取当前毫秒时间
        $time = msectime();

        for ($i = 0; $i <= 10; $i++) {
            // 接收消息参数
            // $msg     = $request->params['msg'];
            $msg     = '消息 ' . $i;
            $amqpMsg = new AMQPMessage($msg);
            // 发布
            $channel->basic_publish($amqpMsg, '', 'hello');
            // 记录下所有要发送的消息 消息的总和
            (new Redis(config('app.redis')))->hset('hello', $amqpMsg->delivery_info['delivery_tag'], $i);

            // 阻塞等待消息确认，单个确认 341ms
            // $channel->wait_for_pending_acks();

            // 批量确认，每次确认100个 187ms
            /*  if ($i % 100 == 0) {
        $channel->wait_for_pending_acks();
        } */
        }

        // 异步消息确认 140ms
        $channel->wait_for_pending_acks();

        // 关闭连接
        RabbitMqConnection::closeConnectionAndChannel($channel, $connection);

        // 显示时间
        echo '耗时' . (msectime() - $time) . 'ms' . PHP_EOL;
    }

}
