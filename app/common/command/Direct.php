<?php

// RabbitMQ 直连 练习
namespace app\common\command;

use app\common\lib\classes\rabbitmq\RabbitMqConnection;
use think\console\Command;
use think\console\Input;
use think\console\Output;
use think\facade\Log;

class Direct extends Command
{
    protected function configure()
    {
        parent::configure(); // TODO: Change the autogenerated stub
        $this->setName('direct');
    }

    protected function execute(Input $input, Output $output)
    {
        // 获取连接对象
        $connection = RabbitMqConnection::getConnection();
        // 获取通道
        $channel = $connection->channel();

        // 通道声明交换机以及交换类型
        $channel->exchange_declare('logs_direct', 'direct', false, true, true);

        // 创建一个临时队列并且获取临时队列名称
        list($queue_namme, ) = $channel->queue_declare('', false, true, true, false);
        // 将队列名与交换器名进行绑定，并指定routing_key
        // 队列基于routing_key绑定交换机，一个交换机可以绑定多个路由，队列也是
        $channel->queue_bind($queue_namme, 'logs_direct', 'info');
        $channel->queue_bind($queue_namme, 'logs_direct', 'error');
        $channel->queue_bind($queue_namme, 'logs_direct', 'warning');
        echo "[*] Waiting for logs. To exit press CTRL+C \n";

        $callback = function ($msg) {
            // echo "[x] 消费者1-" . $msg->delivery_info['routing_key'] . ":$msg->body \n";
            // echo "[x] 消费者2-" . $msg->delivery_info['routing_key'] . ":$msg->body \n";
            echo "[x] 消费者3-" . $msg->delivery_info['routing_key'] . ":$msg->body \n";
            // 保存到日志，这里可以用于日后程序错误的日志输出
            Log::error("Msg: $msg->body");
        };
        // 获取消费的消息
        $channel->basic_consume($queue_namme, '', false, true, false, false, $callback);

        // 监听通道消息
        while (count($channel->callbacks)) {
            $channel->wait();
        }

        // 关闭连接
        RabbitMqConnection::closeConnectionAndChannel($connection, $channel);
    }

}
