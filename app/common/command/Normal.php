<?php

// 死信队列练习 - 普通消费者
namespace app\common\command;

use app\common\lib\classes\rabbitmq\RabbitMqConnection;
use PhpAmqpLib\Wire\AMQPTable;
use think\console\Command;
use think\console\Input;
use think\console\Output;
use think\facade\Log;

class Normal extends Command
{
    protected function configure()
    {
        parent::configure(); // TODO: Change the autogenerated stub
        $this->setName('normal');
    }

    protected function execute(Input $input, Output $output)
    {
        // 获取连接
        $connection = RabbitMqConnection::getConnection(['vhost' => 'order']);
        // 获取通道
        $channel = $connection->channel();

        // 普通交换机名称
        $normal_exchange = 'normal_exchange';
        // 普通队列名称
        $normal_queue = 'normal_queue';
        // 普通routing_key
        $normal_routing_key = 'normal_routing_key';

        // 声明交换机
        $channel->exchange_declare($normal_exchange, 'direct', false, false, false);
        // 将队列名与交换机名进行绑定，并指定routing_key
        $channel->queue_bind($normal_queue, $normal_exchange, $normal_routing_key);
        // 声明交换机
        $channel->exchange_declare($normal_exchange, 'direct', false, false, false);;

        echo "[*] Waiting for logs. To exit press CTRL+C \n";

        $callback = function ($msg) {
            echo "普通消费者: $msg->body \n";
            // 确认消息已被消费，从生产队列中移除
            // 第三种死信情况 消息被拒
            // 这里如果不应答，并且退出连接，那么消费就会跑到死信队列中，状态是未确认
            $msg->ack();
        };

        // 设置消费成功后才能继续进行下一个消费
        $channel->basic_qos(null, 1, null);
        
        // 开启消费no_ack=false,设置为手动应答
        $channel->basic_consume($normal_queue, '', false, false, false, false, $callback);

        // 不断循环消费
        while ($channel->is_open()) {
            $channel->wait();
        }

        // 关闭连接
        RabbitMqConnection::closeConnectionAndChannel($channel, $connection);
    }

}
